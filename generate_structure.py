import os
import argparse
import re
from colorama import Fore, Style, init

init(autoreset=True)

VERSION = "2.0"

def clean_line(line):
    """Cleans a line from structure.txt by removing visual characters and comments."""
    line = re.sub(r'^[\s│├└─]+', '', line)
    line = line.split('#')[0]
    return line.strip()

def get_indent_level(line):
    """Calculates indent level based on leading spaces and tree characters."""
    stripped_line = line.lstrip(' │├└─')
    indent = len(line) - len(stripped_line)
    return indent

def read_structure(structure_file):
    """Parses structure.txt into a list of (indent_level, cleaned_path) tuples."""
    structure = []
    with open(structure_file, 'r', encoding='utf-8') as f:
        lines = f.readlines()

    for line in lines:
        if line.strip():  # Skip empty lines
            cleaned = clean_line(line)
            if cleaned:
                indent = get_indent_level(line)
                structure.append((indent, cleaned))
    return structure

def build_full_paths(parsed_structure):
    """Builds a list of full paths based on indentation, ignoring the first root folder."""
    full_paths = []
    stack = []
    root_skipped = False

    for indent, name in parsed_structure:
        if not root_skipped:
            # Skip the first folder line
            root_skipped = True
            continue

        while stack and stack[-1][0] >= indent:
            stack.pop()

        current_path = os.path.join(*(level[1] for level in stack), name)
        full_paths.append(current_path)

        if name.endswith('/'):
            stack.append((indent, name.rstrip('/')))

    return full_paths

def create_path(path, overwrite=False, dry_run=False):
    """Creates a folder or file based on path."""
    if path.endswith('/'):
        if os.path.exists(path):
            print(Fore.YELLOW + f"Folder exists: {path}")
            return
        if not dry_run:
            os.makedirs(path, exist_ok=True)
        print(Fore.GREEN + f"Created folder: {path}")
    else:
        folder = os.path.dirname(path)
        if folder and not os.path.exists(folder):
            if not dry_run:
                os.makedirs(folder, exist_ok=True)
            print(Fore.GREEN + f"Created parent folder: {folder}")
        if os.path.exists(path):
            if not overwrite:
                print(Fore.YELLOW + f"File exists: {path}")
                return
            else:
                if not dry_run:
                    os.remove(path)
        if not dry_run:
            with open(path, 'w') as fp:
                fp.write(f"# File: {path}\n# Auto-generated by generate_structure.py\n# Description: \n")
        print(Fore.GREEN + f"Created file: {path}")

def create_gitignore():
    """Creates a standard .gitignore file for Python projects."""
    if not os.path.exists(".gitignore"):
        with open(".gitignore", 'w') as f:
            f.write("""# Python
__pycache__/
*.pyc
*.pyo
*.pyd

# Environment
.env
.venv/
env/
venv/

# VSCode
.vscode/

# Mac
.DS_Store

# Logs
*.log
logs/

# Other
*.sqlite3
""")
        print(Fore.GREEN + "Created .gitignore file.")

def create_ci_workflow():
    """Creates a basic GitHub Actions workflow to check Python syntax."""
    os.makedirs(".github/workflows", exist_ok=True)
    workflow_path = ".github/workflows/python-ci.yml"
    if not os.path.exists(workflow_path):
        with open(workflow_path, 'w') as f:
            f.write("""name: Python Syntax Check

on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]

jobs:
  lint:
    runs-on: ubuntu-latest
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Set up Python
      uses: actions/setup-python@v5
      with:
        python-version: '3.x'

    - name: Syntax Check
      run: |
        echo "Running Python Syntax Check..."
        python -m compileall .
""")
        print(Fore.GREEN + "Created GitHub Actions workflow for syntax check.")

def main(structure_file, dry_run=False, create_ignore=False, create_ci=False):
    print(Fore.MAGENTA + f"\nProject Structure Generator v{VERSION}\n")

    parsed_structure = read_structure(structure_file)
    full_paths = build_full_paths(parsed_structure)

    overwrite_all = False

    for path in full_paths:
        if os.path.exists(path) and not overwrite_all:
            choice = input(f"⚠️  {path} already exists. Overwrite? (y = yes, n = no, a = yes to all): ").lower()
            if choice == 'y':
                create_path(path, overwrite=True, dry_run=dry_run)
            elif choice == 'n':
                print(Fore.CYAN + f"Skipped: {path}")
            elif choice == 'a':
                overwrite_all = True
                create_path(path, overwrite=True, dry_run=dry_run)
        else:
            create_path(path, overwrite=overwrite_all, dry_run=dry_run)

    if create_ignore:
        create_gitignore()

    if create_ci:
        create_ci_workflow()

if __name__ == "__main__":
    parser = argparse.ArgumentParser(description="Generate a project structure from a text file.")
    parser.add_argument('--file', type=str, default='structure.txt', help="Path to structure definition file.")
    parser.add_argument('--dry-run', action='store_true', help="Simulate creation without making changes.")
    parser.add_argument('--gitignore', action='store_true', help="Create a .gitignore file.")
    parser.add_argument('--ci', action='store_true', help="Create GitHub Actions workflow for syntax checking.")
    
    args = parser.parse_args()
    main(args.file, dry_run=args.dry_run, create_ignore=args.gitignore, create_ci=args.ci)
